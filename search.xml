<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Jsoup入门使用Java精确提取HTML数据</title>
    <url>/tinkerbaby.github.io/posts/get_data_from_HTML/</url>
    <content><![CDATA[<p>jsoup is a Java library for working with real-world HTML. It provides a very convenient API for fetching URLs and extracting and manipulating data, using the best of HTML5 DOM methods and CSS selectors.<br>翻译：jsoup是一个用于处理实际HTML的Java库。它提供了一个非常方便的API，可以使用HTML5 DOM方法和CSS选择器来获取url、提取和操作数据。</p>
<p>jsoup implements the WHATWG HTML5 specification, and parses HTML to the same DOM as modern browsers do.<br>翻译：jsoup实现了WHATWG HTML5规范，并将HTML解析为与现代浏览器相同的DOM。</p>
<p>jsoup的主要功能如下：</p>
<ol>
<li>从一个URL，文件或字符串中解析HTML；</li>
<li>使用DOM或CSS选择器来查找、取出数据；</li>
<li>可操作HTML元素、属性、文本；<br>jsoup是基于MIT协议发布的，可放心使用于商业项目。<br>关于Jsoup的更多介绍，请访问Jsoup的官网：<a href="http://jsoup.org/" target="_blank" rel="noopener">http://jsoup.org/</a></li>
</ol>
<p><strong>这篇文章搬运了Jsoup的一些用法和例子，更多详情请到官网阅读Cookbook</strong></p>
<a id="more"></a>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>如果你和我一样使用的是Maven管理Java项目，那你不需要下载Jsoup的jar包，只需要在POM文件的<code>&lt;dependencies&gt;</code>部分加入下面的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;!-- jsoup HTML parser library @ https:&#x2F;&#x2F;jsoup.org&#x2F; --&gt;</span><br><span class="line">  &lt;groupId&gt;org.jsoup&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jsoup&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.13.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>其他情况请参考Jsoup官网：<a href="https://jsoup.org/download" target="_blank" rel="noopener">https://jsoup.org/download</a></p>
<h2 id="从一个简单的例子开始"><a href="#从一个简单的例子开始" class="headerlink" title="从一个简单的例子开始"></a>从一个简单的例子开始</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;First parse&lt;/title&gt;&lt;/head&gt;"</span></span><br><span class="line">  + <span class="string">"&lt;body&gt;&lt;p&gt;Parsed HTML into a doc.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line">Document doc = Jsoup.parse(html);</span><br><span class="line">System.out.println(doc.toString());</span><br><span class="line"><span class="comment">//输出可以看到，我们已经成功将html字符串存放到了DOM树中</span></span><br></pre></td></tr></table></figure>



<h3 id="1-从url、本地解析文档"><a href="#1-从url、本地解析文档" class="headerlink" title="1.从url、本地解析文档"></a>1.从url、本地解析文档</h3><p>Jsoup提供的parse()方法将尝试从您提供的HTML中创建一个干净的解析，而不管HTML是否格式良好。例如没有关闭的标签、隐式标签和创建可靠的文档结构(html包含head和body，并且保证内部的元素是合理的)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从URL中解析HTML</span></span><br><span class="line">Document doc = Jsoup.connect(<span class="string">"http://example.com/"</span>).get();</span><br><span class="line">String title = doc.title();</span><br><span class="line"></span><br><span class="line"><span class="comment">//从文件中解析HTML</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:/Users/admin/Desktop/score.html"</span>);</span><br><span class="line">Document doc = Jsoup.parse(file,<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">File input = <span class="keyword">new</span> File(<span class="string">"/tmp/input.html"</span>);</span><br><span class="line">Document doc = Jsoup.parse(input, <span class="string">"UTF-8"</span>, <span class="string">"http://example.com/"</span>);</span><br></pre></td></tr></table></figure>
<p><code>parse(File in, String charsetName, String baseUri)</code>方法加载和解析HTML文件。如果在加载文件时发生错误，它将抛出一个IOException，您应该适当地处理它。如果你只在本地文件系统工作，完全可以使用姐妹方法<code>parse(File in, String charsetName)</code>，它将文件的地址作为<code>baseUri</code>。</p>
<h3 id="2-用DOM方法遍历document"><a href="#2-用DOM方法遍历document" class="headerlink" title="2.用DOM方法遍历document"></a>2.用DOM方法遍历document</h3><p>Elements 提供了一系列类似DOM的方法来查找elements，并提取和操作它们的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File input = <span class="keyword">new</span> File(<span class="string">"/tmp/input.html"</span>);</span><br><span class="line">Document doc = Jsoup.parse(input, <span class="string">"UTF-8"</span>, <span class="string">"http://example.com/"</span>);</span><br><span class="line"></span><br><span class="line">Element content = doc.getElementById(<span class="string">"content"</span>);</span><br><span class="line">Elements links = content.getElementsByTag(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span> (Element link : links) &#123;</span><br><span class="line">  String linkHref = link.attr(<span class="string">"href"</span>);</span><br><span class="line">  String linkText = link.text();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找elements：</strong></p>
<ul>
<li>getElementById(String id)</li>
<li>getElementsByTag(String tag)</li>
<li>getElementsByClass(String className)</li>
<li>getElementsByAttribute(String key) (and related methods)</li>
<li>Element siblings: siblingElements(), firstElementSibling(), lastElementSibling(); </li>
<li>nextElementSibling(), previousElementSibling()</li>
<li>Graph: parent(), children(), child(int index)</li>
</ul>
<p><strong>element 数据：</strong></p>
<ul>
<li>attr(String key) to get and attr(String key, String value) to set attributes</li>
<li>attributes() to get all attributes</li>
<li>id(), className() and classNames()</li>
<li>text() to get and text(String value) to set the text content</li>
<li>html() to get and html(String value) to set the inner HTML content</li>
<li>outerHtml() to get the outer HTML value</li>
<li>data() to get data content (e.g. of script and style tags)</li>
<li>tag() and tagName()</li>
</ul>
<h3 id="3-使用选择器语法-selector-syntax-获取元素"><a href="#3-使用选择器语法-selector-syntax-获取元素" class="headerlink" title="3.使用选择器语法(selector-syntax)获取元素"></a>3.使用选择器语法(selector-syntax)获取元素</h3><p>jsoup元素支持类似于选择器的CSS(或jquery)语法来查找匹配的元素，这样可以非常方便地找到所需的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File input = <span class="keyword">new</span> File(<span class="string">"/tmp/input.html"</span>);</span><br><span class="line">Document doc = Jsoup.parse(input, <span class="string">"UTF-8"</span>, <span class="string">"http://example.com/"</span>);</span><br><span class="line"></span><br><span class="line">Elements links = doc.select(<span class="string">"a[href]"</span>); <span class="comment">// a with href</span></span><br><span class="line">Elements pngs = doc.select(<span class="string">"img[src$=.png]"</span>);</span><br><span class="line">  <span class="comment">// img with src ending .png</span></span><br><span class="line"></span><br><span class="line">Element masthead = doc.select(<span class="string">"div.masthead"</span>).first();</span><br><span class="line">  <span class="comment">// div with class=masthead</span></span><br><span class="line"></span><br><span class="line">Elements resultLinks = doc.select(<span class="string">"h3.r &gt; a"</span>); <span class="comment">// direct a after h3</span></span><br></pre></td></tr></table></figure>

<p>注意，<strong>select()方法对于<code>Document</code>,<code>Element</code>,<code>Elements</code>都是适用的</strong>，返回元素列表(Elements)，更多内容详见<a href="https://jsoup.org/cookbook/extracting-data/selector-syntax" target="_blank" rel="noopener">Cookbook-Selector</a></p>
<h2 id="分享一段完整的使用Jsoup解析HTML的代码"><a href="#分享一段完整的使用Jsoup解析HTML的代码" class="headerlink" title="分享一段完整的使用Jsoup解析HTML的代码"></a>分享一段完整的使用Jsoup解析HTML的代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.ting.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dataCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"c:/Users/admin/Desktop/score.html"</span>);</span><br><span class="line">        Document doc = Jsoup.parse(file,<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;teamInfo&gt; teams = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Elements allTeams = doc.select(<span class="string">"tr[id^=TR_]"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element team : allTeams) &#123;</span><br><span class="line">            <span class="comment">//读id</span></span><br><span class="line">            String teamId = team.id();</span><br><span class="line">            String[] arr = teamId.split(<span class="string">"_"</span>);</span><br><span class="line">            teamId = arr[arr.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读比分</span></span><br><span class="line">            Elements tds = team.children();</span><br><span class="line">            String full = tds.select(<span class="string">"td.acc_result_full"</span>).eachText().get(<span class="number">0</span>);</span><br><span class="line">            String bg = tds.select(<span class="string">"td.acc_result_bg"</span>).eachText().get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(teamId+" "+full+" "+bg);</span></span><br><span class="line">            teams.add(<span class="keyword">new</span> teamInfo(teamId,full,bg));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (teamInfo t : teams) &#123;</span><br><span class="line">            System.out.println(t.getTeamId()+<span class="string">" "</span>+t.getResult_full()+<span class="string">" "</span>+t.getResult_half());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/tinkerbaby.github.io/posts/undefined/</url>
    <content><![CDATA[<p><img src="http://q6x978b17.bkt.clouddn.com/20190130215207.jpg" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>Element框架下的开发实记</title>
    <url>/tinkerbaby.github.io/posts/element_framwork_notes/</url>
    <content><![CDATA[<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>动态绑定在Vue中是非常常用的，这里的笔记方便查询，<a href="https://cn.vuejs.org/v2/guide/class-and-style.html" target="_blank" rel="noopener">更多</a>。</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//1.绑定HTML属性</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"stateCode ? 'success': 'error'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">:class</span>=<span class="string">"stateCode ? 'el-icon-success' : 'el-icon-warning'"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    &#123;&#123;mes&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//2.绑定CSS样式</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; display: timeRestDisplay&#125;"</span>&gt;</span></span><br><span class="line">    &#123;&#123;timeRest&#125;&#125;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-refresh-right"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//3.同时绑定多个方法事件</span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"primary"</span> </span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">"countDownButton();sendRequestForData()"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:class</span>=<span class="string">"&#123; disabled: !canClick &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    &#123;&#123;content1&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="时间选择器组件"><a href="#时间选择器组件" class="headerlink" title="时间选择器组件"></a>时间选择器组件</h3><p>Vue框架下的时间选择器<code>vue-datepicker</code>有一个轻量级的包<code>vue-datapicker-local</code>，都可以使用。而<strong>Element</strong>框架下也有<code>DatePicker</code>组件。用法自己查<a href="https://cloud.tencent.com/developer/section/1489877" target="_blank" rel="noopener">Element 时间选择器组件</a>。</p>
<h3 id="单文件组件复用"><a href="#单文件组件复用" class="headerlink" title="单文件组件复用"></a>单文件组件复用</h3><p>在主文件中import单文件组件，然后在<code>&lt;template&gt;</code>中随意调用，可以传入不同的参数，如下图所示。</p>
<p><img src="http://q6x978b17.bkt.clouddn.com/%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8.png" alt=""></p>
<h3 id="控制元素显示隐藏"><a href="#控制元素显示隐藏" class="headerlink" title="控制元素显示隐藏"></a>控制元素显示隐藏</h3><p>善用<code>v-show</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-form-item&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;getDataState&quot; v-show&#x3D;&quot;msg &#x3D;&#x3D; &#39;data&#39;? &#39;ture&#39; : &#39;&#39;&quot;&gt;爬赛事&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;getScoreState&quot; v-show&#x3D;&quot;msg &#x3D;&#x3D; &#39;score&#39;? &#39;ture&#39; : &#39;&#39;&quot;&gt;爬赛果&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;stopCatching&quot;&gt;Stop&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>String入门项目开发笔记</title>
    <url>/tinkerbaby.github.io/posts/string_notes/</url>
    <content><![CDATA[<h3 id="持久层、业务层、展现层"><a href="#持久层、业务层、展现层" class="headerlink" title="持久层、业务层、展现层"></a>持久层、业务层、展现层</h3><ol>
<li>持久层：数据访问层又称为DAL层，有时候也称为是持久层，其功能主要是负责数据库的访问。 简单的说法就是实现对数据表的Select（查询），Insert（插入），Update（更新），Delete（删除）等操作。 如果要加入ORM的元素，那么就会包括对象和数据表之间的mapping，以及对象实体的持久化。</li>
<li>业务层：</li>
<li>展现层：</li>
</ol>
<a id="more"></a>

<h3 id="什么是JSP"><a href="#什么是JSP" class="headerlink" title="什么是JSP?"></a>什么是JSP?</h3><p>JavaServer Pages（JSP）是一種技術，用於開發支持動態內容，這有助於開發人員通過使用專用的JSP標簽中插入Java代碼的HTML頁麵的網頁，其中大部分開始 &lt;% 並以標簽 %&gt; 結束。</p>
<p>一個JavaServer頁麵的組件類型為Java servlet，其目的是實現一個用戶界麵的Java Web應用程序。 Web開發人員編寫JSP為文本文件，結合HTML或XHTML代碼，XML元素，並嵌入JSP動作和命令。</p>
<p>使用JSP，用戶通過網頁形式，從數據庫或其他來源目前記錄收集輸入，並動態創建的網頁。</p>
<p>JSP標簽可用於各種目的，例如從數據庫中檢索信息或登記的用戶偏好，訪問JavaBeans組件，傳遞頁麵之間的控製和請求，網頁等之間共享信息</p>
<h3 id="什么是事务-管理"><a href="#什么是事务-管理" class="headerlink" title="什么是事务(管理)"></a>什么是事务(管理)</h3><p>我们在实际业务场景中，经常会遇到数据频繁修改读取的问题。在同一时刻，不同的业务逻辑对同一个表数据进行修改，这种冲突很可能造成数据不可挽回的错乱，所以我们需要用事务来对数据进行管理。</p>
<p>事务必须服从ACID原则。ACID指的是原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。<br>通俗理解，事务其实就是一系列指令的集合。</p>
<ul>
<li>原子性：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。</li>
<li>一致性：事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。</li>
<li>隔离性：在该事务执行的过程中，无论发生的任何数据的改变都应该只存在于该事务之中，对外界不存在任何影响。只有在事务确定正确提交之后，才会显示该事务对数据的改变。其他事务才能获取到这些改变后的数据。</li>
<li>持久性：当事务正确完成后，它对于数据的改变是永久性的。</li>
</ul>
<p><a href="https://blog.csdn.net/gloomy_114/article/details/62048335" target="_blank" rel="noopener">Spring事务管理（一）什么是事务？</a><br><a href="https://blog.csdn.net/gloomy_114/article/details/62233564" target="_blank" rel="noopener">Spring事务管理（二）Spring中的事务管控</a><br><a href="https://blog.csdn.net/gloomy_114/article/details/64443393" target="_blank" rel="noopener">Spring事务管理（三）使用tx标签</a></p>
<h3 id="异常-SQLErrorCodes-loaded-DB2-Derby-H2-HSQL-Informix-MS-SQL-MySQL-Oracle-PostgreSQL-Sybase"><a href="#异常-SQLErrorCodes-loaded-DB2-Derby-H2-HSQL-Informix-MS-SQL-MySQL-Oracle-PostgreSQL-Sybase" class="headerlink" title="异常 SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase]"></a>异常 SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase]</h3><p>使用Spring 的JDBCtemplate 调用数据库的时候<br>出现了如下的问题：<br><code>SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase]</code><br>同时会出现什么<code>Could not retrieve transation read-only status server</code>之类的报错并提示sql语句有问题，一定要多检查！！<br>这个一般是因为SQL语句出错  会报这样的错误。<br>这个时候关注Sql 语句的格式(单引号吖逗号啊等等) 以及字段长度 的问题。<br>这类问题一般是数据库的字段和输入的数据库的数据类型不匹配。比如一个int字段 数据库设置只为int   length 为5  如果你用的sqlYong软件或其他软件在该程序中加了一个length为6的，就会报出次错误，又或者，你输入一个不正确的date格式，数据库会自动转换成0000-00-00，mybatis会识别，这也是一个不正确的，解决办法，就是修改字段类型或者修改数据，使其一致即可。</p>
<h3 id="Navicat连接数据库MySQL报错2059"><a href="#Navicat连接数据库MySQL报错2059" class="headerlink" title="Navicat连接数据库MySQL报错2059"></a>Navicat连接数据库MySQL报错2059</h3><p>解释原因：据说，mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password, 解决问题方法有两种,一种是升级navicat驱动,一种是把mysql用户登录密码加密规则还原成mysql_native_password. 现在说第二种方式<br>命令行进入MySQL数据库<br>输入以下指令，逐行输入，每行后加一个回车:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; #修改加密规则 </span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;; #更新用户密码为123456当然也可以自己指定</span><br><span class="line">FLUSH PRIVILEGES; #刷新权限</span><br></pre></td></tr></table></figure>
<p>原文链接：<a href="https://blog.csdn.net/CheneyKKE/article/details/80272777" target="_blank" rel="noopener">https://blog.csdn.net/CheneyKKE/article/details/80272777</a></p>
<h3 id="IDEA中配置MySQL出现Server-returns-invalid-timezone"><a href="#IDEA中配置MySQL出现Server-returns-invalid-timezone" class="headerlink" title="IDEA中配置MySQL出现Server returns invalid timezone"></a>IDEA中配置MySQL出现Server returns invalid timezone</h3><p>首先，出现该问题的原因是MySQL驱动jar中的默认时区是UTC。</p>
<p>UTC代表的是全球标准时间 ，但是我们使用的时间是北京时区也就是东八区，领先UTC八个小时。</p>
<p>因为时区不一致，所以提示Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezone’ property manually<br>服务器返回了无效的时区，去“高级”标签中手工设置“serverTimezon”属性值。</p>
<p><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/error_spring_0001.png" alt="修改"></p>
<h3 id="mysql设置事务隔离级别"><a href="#mysql设置事务隔离级别" class="headerlink" title="mysql设置事务隔离级别"></a>mysql设置事务隔离级别</h3><p>事务隔离级别指的是在处理同一个数据的多个事务中，一个事务修改数据后，其他事务何时能看到修改后的结果。<br><strong>MySQL数据库事务隔离级别主要有四种：</strong></p>
<ul>
<li>Serializable 串行化，一个事务一个事务的执行</li>
<li>Repeatable read 可重复读，无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响</li>
<li>Read committed 读取已提交，其他事务提交了对数据的修改后，本事务就能读取到修改后的数据值</li>
<li>Read uncommitted 读取未提交，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。</li>
</ul>
<p>MySQL数据库默认使用可重复读（ Repeatable read），而使用乐观锁的时候，如果一个事务修改了库存并提交了事务，那其他的事务应该可以读取到修改后的数据值，所以不能使用可重复读的隔离级别，应该修改为读取已提交Read committed。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改全局事务隔离级别，有以上四个可选参数</span><br><span class="line">mysql&gt; set global transaction isolation level read committed;</span><br><span class="line"># 修改当前会话的事务隔离级别</span><br><span class="line">mysql&gt; set session transaction isolation level read committed;</span><br><span class="line"># 查看事务隔离级别</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;%iso%&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>这里修改事务权限的语句是：<code>set [ global | session ] transaction isolation level Read uncommitted | Read committed | Repeatable | Serializable;</code></p>
<p>如果选择global，意思是此语句将应用于之后的所有session，而当前已经存在的session不受影响。</p>
<p>如果选择session，意思是此语句将应用于当前session内之后的所有事务。</p>
<p>如果什么都不写，意思是此语句将应用于当前session内的下一个还未开始的事务。<br><em>重启了电脑之后，mysql的配置是会还原的，所以重启电脑之后需要重新设置一下</em></p>
<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><p>回滚（英语：rollback）是数据库技术中的操作，放弃修改，使数据库状态恢复到此前的某个时刻。这对数据完整性具有关键意义。回滚是数据库事务管理重要一环。</p>
<p>回滚特性通常用数据库日志实现，但也可以用多版本并发控制实现。</p>
<h3 id="servlet是什么呢？"><a href="#servlet是什么呢？" class="headerlink" title="servlet是什么呢？"></a>servlet是什么呢？</h3><h3 id="报错Cannot-resolve-taglib-with-uri-http-java-sun-com-jsp-jstl-core"><a href="#报错Cannot-resolve-taglib-with-uri-http-java-sun-com-jsp-jstl-core" class="headerlink" title="报错Cannot resolve taglib with uri http://java.sun.com/jsp/jstl/core"></a>报错Cannot resolve taglib with uri <a href="http://java.sun.com/jsp/jstl/core" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core</a></h3><p>照着教程写的.jsp文件打开时出现报错，大概就是缺少jar包之类的，解决办法如下：<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/error_spring_0002.png" alt=""></p>
<h3 id="关于jetty运行报错的问题："><a href="#关于jetty运行报错的问题：" class="headerlink" title="关于jetty运行报错的问题："></a>关于jetty运行报错的问题：</h3><p>测试的时候<code>jdbcTemplate.update(String sql,Object[] args)</code>方法调用一直报错，后来修改成了最原始的<code>jdbcTemplate.update(String sql)</code>方法后得以解决，就是书写太麻烦了：<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/error_spring_0004.png" alt=""><br>希望可以尝试到别的解决办法。<br>解决了测试的问题之后，project还是无法运行，我把代码拷贝给了小洪，他说只是简单的改了下jdk和maven配置，然后修改了数据库密码就能正常运行了。开始我检查了一遍没有问题，但是我输错了url，所以一直是404。找到正确的url以后，jetty又报错无法解析JSP:<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/error_spring_0003.png" alt=""><br>我简直要崩溃了，在小洪的教导下耐心的Google到了一个<a href="https://blog.csdn.net/weixin_38997311/article/details/80626757" target="_blank" rel="noopener">解决方案</a>：<br>“在网上查了相关错误，有的说是jetty跟所使用的jdk版本不匹配导致的。所以我去网上找了最新的jetty插件，发现已经换了网站了这个插件，现在是在eclipse的官网上，所以我看了最新插件的使用方式后，换了插件配置信息，把原先的换成以下：”</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- maven测试插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4.11.v20180605<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>于是jetty:run正常运行了，大功告成。艹！</p>
<h3 id="在IDEA中配置Tomcat容器"><a href="#在IDEA中配置Tomcat容器" class="headerlink" title="在IDEA中配置Tomcat容器"></a>在IDEA中配置Tomcat容器</h3><p>另外补充一下用Tomcat运行project的方法，小洪教我的，首先Google一下Tomcat安装教程，把Tomcat安装好，然后在IDEA中进行配置：<br>1.<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/tomcat_1.png" alt=""></p>
<p>2.<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/tomcat_2.png" alt=""></p>
<p>3.<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/tomcat_3.png" alt=""></p>
<p>4.<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/tomcat_4.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Jetty</tag>
        <tag>Tomcat</tag>
        <tag>Transation</tag>
        <tag>Error</tag>
        <tag>Configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data JPA学习笔记</title>
    <url>/tinkerbaby.github.io/posts/spring_data_JPA_notes/</url>
    <content><![CDATA[<h3 id="Spring-Data学习笔记"><a href="#Spring-Data学习笔记" class="headerlink" title="Spring Data学习笔记"></a>Spring Data学习笔记</h3><p>最近看了这个<a href="https://www.imooc.com/video/14542" target="_blank" rel="noopener">教程</a>学习SpringData技术。老师开头演示了传统的JDBC使用方法，非常的繁琐，需要在逻辑代码中进行配置。每一次操作数据库都要通过建立连接、执行查询、释放资源三部重复的代码，还要写一个JDBCUtil工具类来整合数据库连接和关闭的逻辑：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC工具类：</span></span><br><span class="line"><span class="comment"> * 1） 获取Connection</span></span><br><span class="line"><span class="comment"> * 2） 释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所获得到的JDBC的Connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不建议大家把配置硬编码到代码中</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 最佳实践：配置性的建议写到配置文件中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        String url = "jdbc:mysql:///spring_data";</span></span><br><span class="line"><span class="comment">//        String user = "root";</span></span><br><span class="line"><span class="comment">//        String password = "root";</span></span><br><span class="line"><span class="comment">//        String driverClass = "com.mysql.jdbc.Driver";</span></span><br><span class="line"></span><br><span class="line">        InputStream inputStream =        JDBCUtil.class.getClassLoader().getResourceAsStream("db.properties");</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String url = properties.getProperty(<span class="string">"jdbc.url"</span>);</span><br><span class="line">        String user = properties.getProperty(<span class="string">"jdbc.user"</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">"jdbc.password"</span>);</span><br><span class="line">        String driverClass = properties.getProperty(<span class="string">"jdbc.driverClass"</span>);</span><br><span class="line"></span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放DB相关的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> statement</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(ResultSet resultSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Statement statement, Connection connection)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为了避免这样繁琐的配置操作，Spring框架内置的 JdbcTemplate模板来了，它将数据的配置独立到了<code>.xml</code>文件中，和逻辑代码独立开来，很大程度简化了代码，助力开发：</p>
<ul>
<li>添加Maven依赖(搜索<code>Maven Repository</code>,在Maven仓库中找到需要的依赖)<br>这里需要添加两个依赖：<code>spring-jdbc</code>&amp;<code>spring-context</code>?</li>
<li>配置<code>beans.xml</code>:DataSource&amp;JdbcTemplate</li>
<li>开发spring jdbc版本的query和save方法</li>
<li>写Test Case</li>
</ul>
<p>在Spring中，我们将<code>beans.xml</code>配置文件放在<code>Resources</code>文件夹下,这里截取部分主要内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///spring_data"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentDAO"</span> <span class="attr">class</span>=<span class="string">"com.imooc.dao.StudentDAOSpringJdbcImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">ref</span>=<span class="string">"jdbcTemplate"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面是视频中的代码，由于各种更新，我在《精通Spring 4.x》中学习的下面的代码也是可行的，原理逻辑是一样的，自己对比：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描类包，将标注Spring注解的类自动转化Bean，同时完成Bean的注入 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.smart.dao"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.smart.service"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">p:driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">p:url</span>=<span class="string">"jdbc:mysql://localhost:3306/sampledb"</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">p:username</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">p:password</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 配置Jdbc模板  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">p:dataSource-ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">p:dataSource-ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结弊端</strong></p>
<ul>
<li>DAO has many many code</li>
<li>DAOImpl has many duplicate code</li>
<li>Develop the page and other functions对于开发分页和开发其他方法工作量很大</li>
</ul>
<h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><p>PS:这部分的总结参考<a href="https://segmentfault.com/a/1190000013869585" target="_blank" rel="noopener">这里</a><br><strong>SpringData JPA只是SpringData中的一个子模块<br>JPA是一套标准接口，而Hibernate是JPA的实现<br>SpringData JPA 底层默认实现是使用Hibernate</strong><br>（Hibernate是什么呢？Hibernate是一种Java语言下的对象关系映射(ORM)解决方案。是一种ORM框架，全称为 Object_Relative DateBase-Mapping，在Java对象与关系数据库之间建立某种映射，以实现直接存取Java对象！通俗点说，就是Hibernate能将一个领域对象绑定到数据库的一张表上，无论你是想新建表还是CRUD这张表的数据，你只需要对这个类进行操作就可以了，而不需要直接去操作数据库，教程中的实例就是雇员:  先开发实体类===&gt;自动生成对应的数据表）</p>
<h4 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h4><p>首先我们要写配置文件，也就是POM和<code>resources</code>里面的<code>.xml</code>文件。这部分我踩了个坑，我根据教程写好POM配置以后，并没有办法测试<code>SpringDataTest</code>。报错信息第一句是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.sql.SQLException: Unknown system variable &#39;query_cache_size&#39;</span><br></pre></td></tr></table></figure>
<p>感谢<a href="https://blog.csdn.net/qq_21870555/article/details/80711187" target="_blank" rel="noopener">isxuran</a>给我提供的解决方案，原因是mysql-connecter-java的版本过低，很显然是数据库驱动程序与数据库版本不对应。所以我修改了<code>mysql-connector-java</code>的依赖版本，由教程中的<code>5.1.38</code>改成了<code>5.1.6</code>。为什么选择<code>5.1.6</code>呢，我只是在<code>maven repository</code>里网上找了一个使用率较高的进行尝试，没有报错，问题解决。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ting<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdataPratice<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--spring--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--spring data jpa--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-entitymanager<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.6.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>beans.xml</code>中主要配置了数据源<code>dataSource</code>、Hibernate会用到的<code>EntityManagerFactory</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jpa</span>=<span class="string">"http://www.springframework.org/schema/data/jpa"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1 配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/spring_data"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2 配置EntityManagerFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"entityManagerFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jpaVendorAdapter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"packagesToScan"</span> <span class="attr">value</span>=<span class="string">"com.ting"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jpaProperties"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--命名策略--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.ejb.naming_strategy"</span>&gt;</span>org.hibernate.cfg.ImprovedNamingStrategy<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--使用的方言，这里我们用的是Mysql--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQL5InnoDBDialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--查询时是否显示sql语句--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否格式化，这里选择格式化的好处是控制台输出的Hibernate语句会分行清晰的显示，否则会一行到底看不清楚，下文附对比图--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!--自动创建领域对象对应的数据表--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--3 配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.jpa.JpaTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"entityManagerFactory"</span> <span class="attr">ref</span>=<span class="string">"entityManagerFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--4 配置支持注解的事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--5 配置spring data--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">"com.ting"</span> <span class="attr">entity-manager-factory-ref</span>=<span class="string">"entityManagerFactory"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--能够自动扫描指定包中的文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.ting"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Hibernate格式化与不格式化对比图(绿色框内的是格式化后的输出)：<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/springData_03.png" alt=""></p>
<p>接着我们只需要写好domain object和测试类，进行单元测试即可：<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/springData_01.png" alt=""></p>
<p>单元测试通过后我们会发现数据库中已经新建了一个<code>employee</code>表：<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/springData_02.png" alt=""></p>
<p>然后我们再修改一下<code>beans.xml</code>中的事务管理配置、实现<code>repository</code>接口即可。</p>
<h4 id="Spring-Data-JPA进阶"><a href="#Spring-Data-JPA进阶" class="headerlink" title="Spring Data JPA进阶"></a>Spring Data JPA进阶</h4><ol>
<li><p>Repository类的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ting.domain.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Employee</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1) <code>Repository</code>是一个空接口，这种接口称为<strong>标记接口</strong><br>没有包含方法声明的接口<br>2) 如果我们定义的接口<code>EmployeeRepository</code>继承了核心的接口<code>Repository</code>，那么就是告诉了Spring来管理我们的接口。假如我们没有继承的会，运行就会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;com.ting.repository.EmployeeRepository&#39; available</span><br></pre></td></tr></table></figure>
<p>这说明你没有继承核心接口，那么Spring就找不到你定义的接口。<br>另外我们也可以用注释来代替继承语句，作用是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ting.domain.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.RepositoryDefinition;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RepositoryDefinition</span>(domainClass = Employee<span class="class">.<span class="keyword">class</span>,<span class="title">idClass</span> </span>= Integer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">EmployeeRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Repository子类接口：CrudRepository,JpaRepository,PagingAndSortingRepository,JpaSpecificationExecutor</p>
</li>
</ol>
<p><em>在IDEA中crtl+t/h点击相应的类查看继承关系</em><br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/Repository%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt=""></p>
<ul>
<li>CrudRepository:继承Repository，实现了CRUD相关操作</li>
<li>PagingAndSortingRepository:继承CrudRepository，实现了分页排序的相关方法</li>
<li>JpaRepository:继承PagingAndSortingRepository，实现JPA规范相关的方法</li>
</ul>
<ol start="3">
<li>使用Repository接口查询方法定义规则和使用</li>
</ol>
<p><img src="https://images2017.cnblogs.com/blog/779102/201707/779102-20170729001326368-156348206.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// where name like ?% and age &lt;?</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">findByNameStartingWithAndAgeLessThan</span><span class="params">(String name, Integer age)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// where name like %? and age &lt;?</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">findByNameEndingWithAndAgeLessThan</span><span class="params">(String name, Integer age)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// where name in (?,?....) or age &lt;?</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">findByNameInOrAgeLessThan</span><span class="params">(List&lt;String&gt; names, Integer age)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// where name in (?,?....) and age &lt;?</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">findByNameInAndAgeLessThan</span><span class="params">(List&lt;String&gt; names, Integer age)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>弊端：</strong><br>  1）方法名会比较长： 约定大于配置<br>  2）对于一些复杂的查询，是很难实现<br>因此，对于这种情况下还是要写SQL语句简单得多。所以又引入了<code>@Query</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select o from Employee o where id=(select max(id) from Employee t1)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmployeeByMaxId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"select o from Employee o where o.name=?1 and o.age=?2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">queryParams1</span><span class="params">(String name, Integer age)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"select o from Employee o where o.name=:name and o.age=:age"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">queryParams2</span><span class="params">(@Param(<span class="string">"name"</span>)</span>String name, @<span class="title">Param</span><span class="params">(<span class="string">"age"</span>)</span>Integer age)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"select o from Employee o where o.name like %?1%"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">queryLike1</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"select o from Employee o where o.name like %:name%"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">queryLike2</span><span class="params">(@Param(<span class="string">"name"</span>)</span>String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//nativeQuery = true 打开原生态查询</span></span><br><span class="line"><span class="meta">@Query</span>(nativeQuery = <span class="keyword">true</span>, value = <span class="string">"select count(1) from employee"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于修改数据，需要增加Modify注解、并且一定要在事务的管理下才能修改数据，读取不需要事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"update Employee o set o.age = :age where o.id = :id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(@Param(<span class="string">"id"</span>)</span>Integer id, @<span class="title">Param</span><span class="params">(<span class="string">"age"</span>)</span>Integer age)</span>;</span><br></pre></td></tr></table></figure>

<p>补充知识：<a href="https://blog.csdn.net/zt15732625878/article/details/78378995" target="_blank" rel="noopener">【JPQL】–JPQL和SQL的比较</a></p>
<p>然后在service层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ting.services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ting.repository.EmployeeRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span> <span class="comment">//告诉Spring这是Service层</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//注入，注意注入的前提是在beans.xml中定义了&lt;context:component-scan base-package="com.ting"/&gt;上下文扫描路径</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository employeeRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">//告诉Spring要添加事务管理，否则无法执行修改数据库的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer id,Integer age)</span> </span>&#123;</span><br><span class="line">        employeeRepository.update(id,age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事务在Spring data中的使用：<br>1）事务一般是在Service层<br>2）@Query、 @Modifying、@Transactional的综合使用</p>
<ol start="4">
<li><p>使用CrudRepository接口：<br>这个接口继承源代码所提供的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;</span><br><span class="line">&lt;S extends T&gt; <span class="function">Iterable&lt;S&gt; <span class="title">save</span><span class="params">(Iterable&lt;S&gt; entities)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">findOne</span><span class="params">(ID id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(ID id)</span></span>;</span><br><span class="line"><span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Iterable&lt;ID&gt; ids)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(ID id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(T entity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用这个接口我们可以实现对数据库的批量操作CRUD</p>
</li>
<li><p>使用分页PagingAndSortingRepository接口：<br><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/PagingAndSortingRepositoryInterface.png" alt=""></p>
</li>
</ol>
<p>EmployeePagingAndSortingRepositoryTest.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ting.services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ting.domain.Employee;</span><br><span class="line"><span class="keyword">import</span> com.ting.repository.EmployeeCrudRepository;</span><br><span class="line"><span class="keyword">import</span> com.ting.repository.EmployeePagingAndSortingRepository;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeePagingAndSortingRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> EmployeePagingAndSortingRepository employeePagingAndSortingRepository = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        employeePagingAndSortingRepository = ctx.getBean(EmployeePagingAndSortingRepository<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"setup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"tearDown"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意page参数index从0开始</span></span><br><span class="line">        Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        Page&lt;Employee&gt; page = employeePagingAndSortingRepository.findAll(pageable);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"查询的总页数"</span> + page.getTotalPages());</span><br><span class="line">        System.out.println(<span class="string">"查询的总记录数"</span> + page.getTotalElements());</span><br><span class="line">        System.out.println(<span class="string">"当前第几页"</span> + (page.getNumber()+<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"当前页面的集合"</span> + page.getContent().toString());</span><br><span class="line">        System.out.println(<span class="string">"当前页面的记录数"</span> + page.getNumberOfElements());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>使用JpaRepository接口<br>接口源代码所提供的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort sort)</span></span>;</span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Iterable&lt;ID&gt; ids)</span></span>;</span><br><span class="line">&lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">save</span><span class="params">(Iterable&lt;S&gt; entities)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line">&lt;S extends T&gt; <span class="function">S <span class="title">saveAndFlush</span><span class="params">(S entity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; entities)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteAllInBatch</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">T <span class="title">getOne</span><span class="params">(ID id)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>补充一个JpaSpecificationExecutor接口<br>使用时同时<code>extends JpaRepository&lt;Employee,Integer&gt;,JpaSpecificationExecutor&lt;Employee&gt;</code><br>Specification封装了JPA Criteria查询条件，可以操作分页、排序、条件查询.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Sort.Order order = <span class="keyword">new</span> Sort.Order(Sort.Direction.ASC,<span class="string">"id"</span>);</span><br><span class="line">        Sort sort = <span class="keyword">new</span> Sort(order);</span><br><span class="line"></span><br><span class="line">        Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">1</span>,<span class="number">5</span>,sort);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Root:我们要查询的类型（Employee)</span></span><br><span class="line"><span class="comment">         * query:添加查询条件</span></span><br><span class="line"><span class="comment">         * cb:构建Predicate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Specification&lt;Employee&gt; specification = <span class="keyword">new</span> Specification&lt;Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;Employee&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//root(employee(age))</span></span><br><span class="line">                Path path = root.get(<span class="string">"age"</span>);</span><br><span class="line">                <span class="keyword">return</span>  cb.gt(path,<span class="number">50</span>); <span class="comment">//gt:greater than</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Page&lt;Employee&gt; page = employeeJpaSpecificationRepository.findAll(specification,pageable);</span><br><span class="line">        System.out.println(<span class="string">"查询的总页数"</span> + page.getTotalPages());</span><br><span class="line">        System.out.println(<span class="string">"查询的总记录数"</span> + page.getTotalElements());</span><br><span class="line">        System.out.println(<span class="string">"当前第几页"</span> + (page.getNumber()+<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"当前页面的集合"</span> + page.getContent().toString());</span><br><span class="line">        System.out.println(<span class="string">"当前页面的记录数"</span> + page.getNumberOfElements());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Data</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Java中的继承</title>
    <url>/tinkerbaby.github.io/posts/polymorphism_in_java/</url>
    <content><![CDATA[<p>示例中定义了一个基类(父类、超类)<code>Employee</code>，然后<code>class Manager extends Employee</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="comment">//..省略getter和setter以及构造方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> bonus; <span class="comment">//奖金</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h2><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>这里我们希望调用超类中的getSalary()方法，而不是自调用，需要使用特定的关键字<code>super</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用超类中带有n,s,year,month,day参数的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String n, <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(n,s,year,month,day);<span class="comment">//必须写在第一句</span></span><br><span class="line">	bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();<span class="comment">//调用超类中的getSalary()方法</span></span><br><span class="line">	<span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注意：<code>super</code>不是对象的引用，和<code>this</code>不同，它只是一个指示编译器调用超类方法的特殊关键字</em></p>
<ul>
<li><strong>不能删除继承的任何域和方法</strong></li>
<li><strong>如果父类没有不带参数的构造器，子类又没有显示调用其他超类带构造器，系统会报错。</strong></li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个对象变量可以指示多种实际类型的现象被称为多态(Polymorphism).在运行时能够自动地选择调用哪个方法的现象称为动态绑定。<br>一个判断是否应该设计为继承关系的规则：”is-a”规则。</p>
<ul>
<li><strong>动态绑定和静态绑定</strong></li>
</ul>
<ol>
<li><strong>动态绑定</strong>是指在类的继承关系中，编译器在调用函数时可以根据声明类型、方法名、参数去动态调用与之完全匹配的方法。优先调用当前声明的子类的方法<br>一个类中，方法名字和参数列表称为方法的签名，而返回类型不是方法的签名。子类中可以覆盖超类中相同签名的方法，因此在覆盖方法是们一定要保证返回类型的兼容性。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设在超类Employee中有：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getBuddy</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//子类Manager要覆盖这个方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Manager <span class="title">getBuddy</span><span class="params">()</span> </span>&#123;...&#125;<span class="comment">//It's ok to change the return type</span></span><br></pre></td></tr></table></figure></li>
<li>如果是private、static、final方法或着构造器，那么编译器可以准确地知道调用什么方法，这种调用方式称为<strong>静态绑定</strong>。</li>
</ol>
<p><strong>注意：再覆盖方法时，子类方法不能低于超类方法的可见性(public&gt;private)</strong></p>
<h3 id="final关键字：阻止继承"><a href="#final关键字：阻止继承" class="headerlink" title="final关键字：阻止继承"></a>final关键字：阻止继承</h3><p>在定义类的时候使用final修饰符阻止人们定义该类的子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Executive</span> <span class="keyword">extends</span> <span class="title">Manager</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>类中的特定方法也可以被声明为<code>final</code>，这样做子类就不能再覆盖这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>域也可以被声明为<code>final</code>。对于<code>fianl域</code>，构造对象之后就不允许改变它们的值了。不过如果将一个类声明为final，只有其中的方法自动地成为<code>final</code>，而不包括域。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋值给一个子类变量，必须进行类型转换。为避免<code>ClassCastException</code>异常，应该养成一个良好的程序设计习惯：在进行类型转换之前，先查一下能否成功地转换，使用<code>instanceof</code>运算符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager) &#123;</span><br><span class="line">	boss = (Manager) staff[<span class="number">1</span>];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只能在继承层次上进行类型转换</li>
<li>在将超类转换成子类之前，应该使用<code>instanceof</code>进行检查</li>
</ul>
<p><strong>在一般情况下，应该尽量少用类型转换和<code>instanceof</code>运算符</strong></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>使用<code>abstract</code>关键字的方法，不需要实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//no implementation required</span></span><br></pre></td></tr></table></figure>
<p>包含一个或多个抽象方法的类本身必须被声明为抽象的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//抽象方法的具体实现在子类中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类的子类如果没有实现所有的抽象方法，则必须将子类也标为抽象类，因为这种情况下子类中还是有抽象方法。<br><strong>抽象类不能被实例化</strong>，但可以创建一个具体子类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Person(<span class="string">"Vincent"</span>);<span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Student(<span class="string">"Vincent"</span>,<span class="string">"Economics"</span>);<span class="comment">//ok!</span></span><br><span class="line"></span><br><span class="line">Person[] people = <span class="keyword">new</span> Person[<span class="number">2</span>];</span><br><span class="line">people[<span class="number">0</span>] = <span class="keyword">new</span> Student(...);</span><br><span class="line">people[<span class="number">1</span>] = <span class="keyword">new</span> Employee(...);</span><br><span class="line"><span class="keyword">for</span> (Person p:people) &#123;</span><br><span class="line">	System.out.println(p.getName()+<span class="string">","</span>+p.getDescription());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们省略超类中的getDescription()方法，而仅在子类中定义该方法，那我们就不能通过变量p调用getDescription方法了。</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-所有类的超类"><a href="#Object-所有类的超类" class="headerlink" title="Object:所有类的超类"></a>Object:所有类的超类</h2><p>Object类是Java中所有类的超类，即Java中每个类都是由它拓展而来。只有基本类型(primitive types)不是对象，例如数值、字符、布尔类型。所有的数组类，不管是对象数组还是基本类型的数组都拓展自Object类。<br><strong>Object类有一些共同的方法：</strong></p>
<h3 id="1-equals方法"><a href="#1-equals方法" class="headerlink" title="1. equals方法"></a>1. equals方法</h3><p>Object类中的equals方法用于检测两个对象是否相等。Object类中的这个方法返回两个对象是否具有相同的引用，在很多情况下这是没有意义的。所以对于自定义类我们会重写<code>equals</code>方法。<br><strong>相等测试与继承</strong><br>Java语言规范要求equals方法具有：<em>自反性，对称性，传递性，一致性，对于非空x有x.equals(null) = false</em>.<br>书中用了getClass()方法来检测，许多程序元也喜欢用<code>instanceof</code>进行检测，关于instanceof的效果参考<a href="https://blog.csdn.net/liranke/article/details/5574791" target="_blank" rel="noopener">langya2007</a>。<br>但是用<code>instanceof</code>检测违背了对称性。例如 <code>e.equals(m)</code>返回true，而<code>m.equals(e)</code>返回false（这里m(manager)是e(employee)的子类）。</p>
<ul>
<li>如果子类能够拥有自己相等的概念，，则对称性需求将强制采用getClass进行检测</li>
<li>如果由超类决定相等的概念，那么就可以用<code>instanceof</code>进行检测，这样可以在不同的子类对象之间进行相等比较。</li>
</ul>
<h3 id="2-hashCode方法"><a href="#2-hashCode方法" class="headerlink" title="2. hashCode方法"></a>2. hashCode方法</h3><p>散列码是由对象导出的一个整型值，散列码是没有规律的，不同对象的散列码基本不同。hashCode方法定义在Object类中，每个对象都有一个默认的散列码，其值为对象的存储地址。<br>字符串String的散列码是由内容导出的，that is内容相同的字符串散列码相同。但是，StringBuffer类没有定义hashCode方法，它的散列码是由Object类的默认hashCode方法到处的对象存储地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String使用下列方法计算散列码：</span></span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length(); i++) &#123;</span><br><span class="line">	hash = <span class="number">31</span> * hash + charAt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以可以理解为什么相同内容的String的散列码相同</span></span><br></pre></td></tr></table></figure>
<p><strong>如果重新定义equals方法，就必须重新定义hashCode方法，以便用户将对象插入到散列表中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用null安全的方法Objects.hashCode()方法获取散列码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">7</span> * Objects.hashCode(name) +</span><br><span class="line">		+ <span class="number">11</span> * <span class="keyword">new</span> Double(salary).hashCode() +</span><br><span class="line">		+ <span class="number">13</span> * Objects.hashCode(hireDay);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要组合多个散列值时，可以调用Objects.hash()并提供多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Objects.hash(name, salary, hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Equals和hashCode定义必须一直，如果x.equals(y)返回true，那么两个对象的散列码必须相同</strong>，例如如果定义Employee.equals比较雇员ID，那么hashCode方法就需要散列ID，而不是雇员的姓名或存储地址。<br>另外，数组类型可以使用Arrays.hashCode()方法计算一个散列码。</p>
<h3 id="3-toString方法"><a href="#3-toString方法" class="headerlink" title="3. toString方法"></a>3. toString方法</h3><p>返回对象值的字符串，且绝大多数toString方法都是返回：类型名[域值]<br><em>只要对象与一个字符串通过操作符<code>+</code>连接起来，Java编译器就会自动地调用 toString()</em><br>Object类定义了toString方法，打印输出对象所属的类名和散列码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(System.out);</span><br><span class="line"><span class="comment">//输出：java.io.PrintStream@2f6684</span></span><br><span class="line"><span class="comment">//PrintStream类的设计者没有覆盖toString方法</span></span><br></pre></td></tr></table></figure>
<p><strong>!</strong> 数组继承了object类的toString方法，所以在打印数组时我们不用<code>.toString()</code>，而是使用静态方法<code>Arrays.toString(...)</code>或者<code>Arrays.deepToString(...)</code>(多维数组)。</p>
<h2 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h2><p>Example: ArrayList&lt;&gt;</p>
<h2 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h2><p><code>Integer</code>,<code>Long</code>,<code>Float</code>,<code>Double</code>,<code>Short</code>,<code>Byte</code>,<code>Character</code>,<code>Void</code>,<code>Boolean</code>(前6个类派生自公共的超类<code>Number</code>)。对象包装器类是不可变的，一旦够着了包装器就不允许更改包装在其中的值，且包装器类都是final，不能定义子类。<br>自动装箱拆箱是非常普遍的~<br><strong>如何编写一个修改数值参数值的方法：</strong>需要使用在org.omg.CORBA中定义的<code>holder</code>类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">triple</span><span class="params">(IntHolder x)</span> </span>&#123;</span><br><span class="line">	x.value = <span class="number">3</span> * x.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是错误示范：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">triple</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//won't work</span></span><br><span class="line">	x = <span class="number">3</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">triple</span><span class="params">(Integer x)</span> </span>&#123; <span class="comment">//won't work</span></span><br><span class="line">	x = <span class="number">3</span> * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h2><p>我们看<code>printf</code>的方法定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String fmt,Object... args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> format(fmt,args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>...</code>表明这个方法可以接受任意数量的对象(除fmt参数外)</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>ClassName.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ClassName &#123;</span><br><span class="line">    STRING(<span class="string">"String"</span>),INTEGER(<span class="string">"Integer"</span>),BYTE(<span class="string">"Byte"</span>),</span><br><span class="line">    BIGDECIMAL(<span class="string">"BigDecimal"</span>),TIME(<span class="string">"time"</span>),STRING_LIKE(<span class="string">"String-like"</span>),</span><br><span class="line">    LONG(<span class="string">"Long"</span>),INTEGER_IN(<span class="string">"Integer-in"</span>),DATE_BETWEEN(<span class="string">"Date-between"</span>),</span><br><span class="line">    JOIN(<span class="string">"Join"</span>),SUBQUERY(<span class="string">"SubQuery"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lowercase;</span><br><span class="line">    ClassName(String lowercase) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lowercase = lowercase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLowercase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lowercase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EnumTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"Enter a classname:"</span>);</span><br><span class="line">        String input = scanner.next().toUpperCase();</span><br><span class="line">        ClassName size = Enum.valueOf(ClassName<span class="class">.<span class="keyword">class</span>, <span class="title">input</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"enter classname is:"</span> + size.getLowercase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出：</span></span><br><span class="line"><span class="comment">*Enter a classname:</span></span><br><span class="line"><span class="comment">*string</span></span><br><span class="line"><span class="comment">*enter classname is:String</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在比较两个枚举类型的值时，不需要用equals，而直接使用”==“。所有枚举类型都是Enum类的子类，他们继承了Enum的许多方法，例如<code>toString()</code>, <code>Enum.valueOf()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassName.STRING.toString();<span class="comment">//返回字符串"STRING"</span></span><br><span class="line">ClassName cn = Enum.valueOf(ClassName.class, "STRING");</span><br><span class="line">ClassName[] values = ClassName.values();<span class="comment">//返回包含全部枚举值的数组</span></span><br><span class="line"><span class="keyword">int</span> index = ClassName.STRING.ordinal();<span class="comment">//返回枚举常量STRING的位置0</span></span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射库提供了一个非常丰富且精心设计的工具集，以便编写能够移动操作Java代码的程序。<br>能够分析类能力的程序称为<strong>反射</strong>(reflective)，反射机制功能：</p>
<ul>
<li>在运行中分析类的能力</li>
<li>在运行中查看对象，例如编写一个toString方法供所有类使用</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象，这个对象很像C++中的函数指针</li>
</ul>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。<br><strong>通过专门的Java类<code>Class</code>可以访问这些信息</strong></p>
<ol>
<li><p>Object类中的<code>getClass()</code>方法返回一个Class类型的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">...</span><br><span class="line">Class c1 = e.getClass();</span><br></pre></td></tr></table></figure>
<p>一个Class对象表示一个特定类的属性。</p>
</li>
<li><p>最常用的Class方法是getName()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(e.getClass().getName);</span><br><span class="line"><span class="comment">//输出： Employee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果类在一个包里，包的名字也作为类名的一部分</span></span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">Class c2 = d.getClass();</span><br><span class="line">String name = c2.getName();<span class="comment">//name is set to "java.util.Date"</span></span><br></pre></td></tr></table></figure></li>
<li><p>调用静态方法<code>forName()</code>获得类名对应的Class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String className = <span class="string">"java.util.Date"</span>;</span><br><span class="line">Class c1 = Class.forName(className);<span class="comment">//注意检查异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取Class对象最简单的方法就是在类名后面加<code>.class</code></p>
</li>
</ol>
<p><em><code>getName()</code>方法应用在数组类型时会返回比较奇怪的名字，历史原因</em><br>虚拟机为每个类型管理一个Class对象。因此可以利用”==”比较两个类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.getClass() == Employee<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>快速创建一个类的实例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object ee = e.getClass().newInstance();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>在可能抛出<strong>已检查异常</strong>的一个或多个方法调用代码放在<strong>try块</strong>中，然后再<strong>catch</strong>子句中提供处理器代码。</p>
<h2 id="继承设计的技巧"><a href="#继承设计的技巧" class="headerlink" title="继承设计的技巧"></a>继承设计的技巧</h2><ol>
<li>将公共操作和域放在超类</li>
<li>不要使用受保护的域<br>protected机制并不能带来很好的保护，一个是因为子类集合是无限的，二是一个包中的所有类都可以访问protected域。</li>
<li>使用继承实现”is-a”关系</li>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>在覆盖方法时，不要改变预期行为</li>
<li>使用多态，而非类型信息。</li>
<li>不要过多的使用反射</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Polymorphism</tag>
        <tag>Inherit</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建记录</title>
    <url>/tinkerbaby.github.io/posts/hexo_note_1/</url>
    <content><![CDATA[<p><a href="http://fanzhenyu.cn/2016/11/30/Github%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">hexo博客搭建教程</a><br>参考：<a href="http://www.hongscar.cn/Hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95.html" target="_blank" rel="noopener">小洪的搭建笔记</a><a href="http://www.hongscar.cn/Hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95.html" target="_blank" rel="noopener">http://www.hongscar.cn/Hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95.html</a></p>
<p>补充搭建记录：</p>
<h3 id="在Next主题中-集成Gitalk评论系统"><a href="#在Next主题中-集成Gitalk评论系统" class="headerlink" title="在Next主题中 集成Gitalk评论系统"></a>在Next主题中 集成Gitalk评论系统</h3><p>教程：<a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">asdfv1929</a></p>
<ol>
<li><p>照着教程做下来第一个常见的报错：</p>
<a id="more"></a>
<p><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/hexo_01.png" alt=""><br>要先用你配置中的的adminUser对应的帐号先登录访问一次文章，然后才会初始化评论。一篇文章的评论对应一个issue，比如我刚刚发现我有一篇文章没有开启评论，也是显示要联系@hongscar添加评论，就是先用这个账号登录，然后大概就会在这个评论项目里添加一条issue，这样其他用户才能访问。</p>
</li>
<li><p>然后部分文章可行了，但中文标题的文章通常会出现如下问题</p>
</li>
</ol>
<p><img src="https://tinkerbabyblog-1301804286.cos.ap-guangzhou.myqcloud.com/hexo_02.png" alt=""><br>Google搜索了一下，是因为域名太长的问题导致gitalk不能处理导致的。因为域名中的中文字会解析成数字符号字母所以url会非常长，另外hexo默认的url还包含文章的日期等等。<br>解决办法就是修改url的默认格式，看<a href="https://zhangjiejun.com/posts/URL_optimization_in_hexo/" target="_blank" rel="noopener">这里</a>。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
